// C++ chip header generator
// Port of sodaCat's generators/cxx/generate_chip_header.py
//
// Generates C++ headers with constexpr integration structs for each
// peripheral instance — parameters, interrupts, and base addresses.

import { findFamily } from '../data.js';
import { deriveNamespace } from './cxx-export.js';

// ── Namespace helpers ────────────────────────────────────────────────

/**
 * Derive the namespace for a chip from its path.
 * e.g. "H7/H742_H753/STM32H742" → family "H7" → "stm32h7"
 */
function deriveChipNamespace(chipPath) {
  const family = chipPath.split('/')[0];
  const fam = findFamily(family);
  if (fam) return fam.display.toLowerCase().replace(/[^a-z0-9_]/g, '');
  return family.toLowerCase();
}

/**
 * Derive namespace for a model from its modelPath.
 * Family-scoped paths like "H7/ADC" → "stm32h7".
 * Shared paths like "USART" → fall back to chipNamespace.
 */
function deriveModelNamespace(modelPath, chipNamespace) {
  if (!modelPath) return chipNamespace;
  const parts = modelPath.split('/');
  if (parts.length >= 2) {
    return deriveNamespace(modelPath);
  }
  return chipNamespace;
}

// ── Parameter / interrupt formatting ─────────────────────────────────

function formatParameters(params) {
  let txt = '';
  for (const p of params) {
    const v = p.value;
    if (typeof v === 'boolean') {
      txt += `\n\t.${p.name} = ${v ? 'true' : 'false'},`;
    } else {
      txt += `\n\t.${p.name} = ${v}u,`;
    }
  }
  return txt;
}

function formatInterrupts(interrupts) {
  let txt = '';
  const seen = new Set();
  const sorted = [...interrupts].sort((a, b) =>
    (a.name || '').localeCompare(b.name || '')
  );
  for (const int of sorted) {
    if (!seen.has(int.name)) {
      seen.add(int.name);
      txt += `\n\t.ex${int.name} = ${int.value}u + interruptOffset,`;
    }
  }
  return txt;
}

// ── Public API ───────────────────────────────────────────────────────

/**
 * Generate a complete C++ chip header.
 * @param {Object} data - Chip data object
 * @param {string} chipPath - Chip path (e.g. "H7/H742_H753/STM32H742")
 * @returns {string} Complete C++ header file content
 */
export function generateChipHeader(data, chipPath) {
  const ns = deriveChipNamespace(chipPath);
  const interruptOffset = data.interruptOffset || 0;
  const instances = data.instances || {};

  // Collect unique models for #include directives
  const models = new Map();
  for (const inst of Object.values(instances)) {
    if (!models.has(inst.model)) {
      models.set(inst.model, inst.modelPath || inst.model);
    }
  }

  // Build includes
  const includes = [...models.keys()].sort()
    .map(m => `#include "${m}.hpp"`)
    .join('\n');

  // Build instance declarations
  let decl = '';
  const sorted = Object.entries(instances).sort((a, b) => a[0].localeCompare(b[0]));
  for (const [name, inst] of sorted) {
    const modelNs = deriveModelNamespace(inst.modelPath, ns);
    const params = formatParameters(inst.parameters || []);
    const ints = formatInterrupts(inst.interrupts || []);
    const addr = inst.baseAddressHex
      || `0x${(inst.baseAddress >>> 0).toString(16).toUpperCase()}`;
    const init = `\n\t.registers = ${addr}u`;

    decl += `\n/** Integration parameters for ${name} */`;
    decl += `\nconstexpr struct ${modelNs}::integration::${inst.model} i_${name} = {`;
    decl += `${params}${ints}${init}`;
    decl += `\n};\n`;
  }

  // Assemble header
  let out = '';
  out += '// Generated by sodaCat Explorer\n';
  out += '#pragma once\n';
  if (includes) out += includes + '\n';
  out += '#include <cstdint>\n';
  out += `\nnamespace ${ns} {\n`;
  out += `\nconstexpr Exception interruptOffset = ${interruptOffset};\t//!< Exception number of first interrupt\n`;
  out += decl;
  out += `\n} // namespace ${ns}\n`;

  return out;
}
